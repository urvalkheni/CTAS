name: CTAS CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ctas

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x, 20.x]
        python-version: [3.9, 3.10, 3.11]

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: |
          frontend/package-lock.json
          backend/package-lock.json

    - name: Setup Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'

    - name: Install Frontend Dependencies
      run: |
        cd frontend
        npm ci

    - name: Install Backend Dependencies
      run: |
        cd backend
        npm ci

    - name: Install Python Dependencies
      run: |
        cd ai-models
        pip install -r requirements.txt

    - name: Run Frontend Tests
      run: |
        cd frontend
        npm test -- --coverage --watchAll=false

    - name: Run Backend Tests
      run: |
        cd backend
        npm test -- --coverage

    - name: Run Python Tests
      run: |
        cd ai-models
        python -m pytest tests/ --cov=. --cov-report=xml

    - name: Lint Frontend Code
      run: |
        cd frontend
        npm run lint

    - name: Lint Backend Code
      run: |
        cd backend
        npm run lint

    - name: Security Audit
      run: |
        cd frontend && npm audit --audit-level high
        cd ../backend && npm audit --audit-level high

    - name: Upload Coverage Reports
      uses: codecov/codecov-action@v3
      with:
        files: ./frontend/coverage/lcov.info,./backend/coverage/lcov.info,./ai-models/coverage.xml

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    strategy:
      matrix:
        service: [frontend, backend, ai-models, data-pipeline, alerts, iot-integration]

    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./${{ matrix.service }}
        file: ./${{ matrix.service }}/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure Kubeconfig
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config

    - name: Deploy to Staging
      run: |
        # Update image tags in K8s manifests
        sed -i "s|image: ctas/|image: ${{ env.REGISTRY }}/${{ github.repository }}/|g" k8s/*.yaml
        sed -i "s|:latest|:develop-${{ github.sha }}|g" k8s/*.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/secrets.yaml
        kubectl apply -f k8s/configmaps.yaml
        kubectl apply -f k8s/
        
        # Wait for rollout
        kubectl rollout status deployment/ctas-backend -n ctas-staging --timeout=600s
        kubectl rollout status deployment/ctas-frontend -n ctas-staging --timeout=600s
        kubectl rollout status deployment/ctas-ai-service -n ctas-staging --timeout=600s

    - name: Run Health Checks
      run: |
        # Wait for services to be ready
        kubectl wait --for=condition=ready pod -l app=ctas-backend -n ctas-staging --timeout=300s
        
        # Run health checks
        BACKEND_URL=$(kubectl get service ctas-backend-service -n ctas-staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        curl -f http://${BACKEND_URL}/health || exit 1

  deploy-production:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
    - uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure Kubeconfig
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config

    - name: Deploy to Production
      run: |
        # Update image tags in K8s manifests
        sed -i "s|image: ctas/|image: ${{ env.REGISTRY }}/${{ github.repository }}/|g" k8s/*.yaml
        sed -i "s|:latest|:main-${{ github.sha }}|g" k8s/*.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/secrets.yaml
        kubectl apply -f k8s/configmaps.yaml
        kubectl apply -f k8s/
        
        # Rolling update with canary deployment
        kubectl patch deployment ctas-backend -n ctas -p '{"spec":{"strategy":{"rollingUpdate":{"maxSurge":1,"maxUnavailable":0}}}}'
        kubectl set image deployment/ctas-backend backend=${{ env.REGISTRY }}/${{ github.repository }}/backend:main-${{ github.sha }} -n ctas
        
        # Wait for rollout
        kubectl rollout status deployment/ctas-backend -n ctas --timeout=600s

    - name: Run Production Health Checks
      run: |
        # Comprehensive health checks
        kubectl wait --for=condition=ready pod -l app=ctas-backend -n ctas --timeout=300s
        kubectl wait --for=condition=ready pod -l app=ctas-frontend -n ctas --timeout=300s
        kubectl wait --for=condition=ready pod -l app=ctas-ai-service -n ctas --timeout=300s
        
        # API health checks
        BACKEND_URL=$(kubectl get service ctas-backend-service -n ctas -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        AI_URL=$(kubectl get service ctas-ai-service -n ctas -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        
        # Backend health
        curl -f http://${BACKEND_URL}/health || exit 1
        
        # AI service health
        curl -f http://${AI_URL}/health || exit 1
        
        # Database connectivity test
        kubectl exec -n ctas deployment/ctas-backend -- node -e "
          const mongoose = require('mongoose');
          mongoose.connect(process.env.MONGODB_URI)
            .then(() => { console.log('DB OK'); process.exit(0); })
            .catch((err) => { console.error('DB Error:', err); process.exit(1); });
        "

    - name: Post-deployment Monitoring
      run: |
        # Set up monitoring alerts
        curl -X POST "${{ secrets.SLACK_WEBHOOK }}" \
          -H "Content-Type: application/json" \
          -d '{
            "text": "ðŸŒŠ CTAS Production Deployment Successful",
            "attachments": [{
              "color": "good",
              "fields": [
                {"title": "Environment", "value": "Production", "short": true},
                {"title": "Version", "value": "${{ github.sha }}", "short": true},
                {"title": "Branch", "value": "${{ github.ref_name }}", "short": true},
                {"title": "Deployed by", "value": "${{ github.actor }}", "short": true}
              ]
            }]
          }'

  security-scan:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
    - uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Run OWASP ZAP security scan
      if: github.ref == 'refs/heads/main'
      run: |
        docker run -t ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
          -t https://ctas.production.domain.com \
          -J zap-report.json || true
        
    - name: Upload Security Scan Results
      uses: actions/upload-artifact@v3
      with:
        name: security-scan-results
        path: |
          trivy-results.sarif
          zap-report.json

  performance-test:
    needs: deploy-staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'

    steps:
    - uses: actions/checkout@v4

    - name: Setup K6
      run: |
        sudo gpg -k
        sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6

    - name: Run Performance Tests
      run: |
        # API Load Testing
        k6 run --vus 10 --duration 5m tests/performance/api-load-test.js
        
        # AI Model Performance Testing
        k6 run --vus 5 --duration 3m tests/performance/ai-model-test.js
        
        # WebSocket Connection Testing
        k6 run --vus 20 --duration 2m tests/performance/websocket-test.js

    - name: Upload Performance Results
      uses: actions/upload-artifact@v3
      with:
        name: performance-test-results
        path: performance-results/
